<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Micropolis+ (Single-File City Builder)</title>
  <style>
    :root {
      --bg: #0e0f13;
      --panel: #171922;
      --panel-2: #1e2230;
      --accent: #50e3c2;
      --accent-2: #8ecbff;
      --text: #e6eef7;
      --muted: #9fb1c3;
      --danger: #ff5865;
      --warn: #ffb86b;
      --ok: #7ce38b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 1fr 320px; height: 100%; }
    #left { position: relative; }
    #right { background: linear-gradient(180deg, var(--panel), var(--panel-2)); border-left: 1px solid #2a3040; display: grid; grid-template-rows: auto auto 1fr auto; }
    #topbar { position: absolute; left: 10px; top: 10px; display: flex; gap: 8px; align-items: center; padding: 8px; background: rgba(0,0,0,0.35); border: 1px solid #2a3040; border-radius: 8px; backdrop-filter: blur(6px); }
    #topbar button { background: #202536; color: var(--text); border: 1px solid #2a3040; border-radius: 6px; padding: 6px 10px; cursor: pointer; }
    #topbar button.active { outline: 2px solid var(--accent); }
    #topbar .speed { display: inline-flex; gap: 6px; }
    #canvas { width: 100%; height: 100%; display: block; background: #1a2030; }
    .panel { padding: 10px 12px; border-bottom: 1px solid #2a3040; }
    .money { font-weight: 700; color: var(--ok); }
    .neg { color: var(--danger); }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .tools { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .tool { background: #22283b; border: 1px solid #2a3040; padding: 8px; border-radius: 8px; text-align: center; cursor: pointer; user-select: none; display:flex; flex-direction:column; align-items:center; gap:4px; }
    .tool .ico { font-size: 18px; line-height: 1; }
    .tool .lbl { font-size: 11px; color: var(--muted); }
    .tool.active { outline: 2px solid var(--accent); }
    select, input[type="range"], input[type="number"], button { background: #202536; color: var(--text); border: 1px solid #2a3040; border-radius: 6px; padding: 6px; }
    .section-title { color: var(--accent-2); margin: 8px 0 6px; font-weight: 700; }
    #log { padding: 10px 12px; border-top: 1px solid #2a3040; height: 160px; overflow: auto; font-size: 12px; color: var(--muted); background: #121520; }
    .pill { padding: 2px 6px; border-radius: 999px; font-size: 12px; background: #2a3042; color: var(--muted); }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; padding: 1px 4px; border: 1px solid #2a3040; border-radius: 4px; background: #1b2233; }
    .small { font-size: 12px; color: var(--muted); }
    #overlayLegend { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 12px; color: var(--muted); }
    #help { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.6); }
    #help .card { width: min(860px, 96vw); max-height: 90vh; overflow: auto; background: #121826; border: 1px solid #2a3040; border-radius: 12px; padding: 16px; }
    #help h2 { margin: 0 0 8px; }
    #help ul { padding-left: 18px; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div id="app">
    <div id="left">
      <canvas id="canvas"></canvas>
      <div id="topbar">
        <button id="newMap">New</button>
        <button id="nccMap">NCC Map</button>
        <button id="saveBtn">Save</button>
        <button id="loadBtn">Load</button>
        <button id="helpBtn">Help</button>
        <span class="pill" id="verPill">v4.1</span>
        <span class="pill" id="datePill">Jan 1900</span>
        <span class="pill" id="popPill">Pop 0</span>
        <div class="speed">
          <button data-speed="0.0">Pause</button>
          <button data-speed="1.0" class="active">Play</button>
          <button data-speed="3.0">Fast</button>
          <button data-speed="10.0">Ultra</button>
        </div>
        <button id="musicBtn">Music: Off</button>
      </div>
    </div>
    <div id="right">
      <div class="panel" id="budgetPanel">
        <div class="row" style="justify-content: space-between">
          <div>
            <div style="font-weight:700">Treasury: <span id="money" class="money">$20,000</span> <label style="margin-left:6px"><input type="checkbox" id="infiniteMoney"> âˆž</label></div>
            <div class="small">Monthly: <span id="monthly" class="pill">$0</span></div>
          </div>
          <div>
            <label>Taxes: <input id="taxRate" type="number" min="0" max="20" step="0.5" value="7" style="width:70px" />%</label>
          </div>
        </div>
      </div>
      <div class="panel">
        <div class="section-title">Tools</div>
        <div class="tools" id="tools"></div>
        <div class="row" style="margin-top:8px">
          <label>Brush <select id="brush">
            <option value="1">1x1</option>
            <option value="2">2x2</option>
            <option value="4">4x4</option>
          </select></label>
          <label>Cost: <span id="costPreview" class="pill">$0</span></label>
        </div>
      </div>
      <div class="panel">
        <div class="section-title">Overlay</div>
        <div class="row">
          <select id="overlay">
            <option value="none">None</option>
            <option value="power">Power</option>
            <option value="water">Water</option>
            <option value="traffic">Traffic</option>
            <option value="pollution">Pollution</option>
            <option value="crime">Crime</option>
            <option value="land">Land Value</option>
            <option value="zones">Zones</option>
            <option value="fire">Fires</option>
            <option value="moisture">Moisture</option>
            <option value="temp">Temperature</option>
            <option value="forest">Forest</option>
            <option value="o2">O2</option>
            <option value="co2">CO2</option>
          </select>
          <button id="queryBtn">Query (Q)</button>
        </div>
        <div id="overlayLegend" style="margin-top:8px"></div>
      </div>
      <div class="panel">
        <div class="section-title">Advisors</div>
        <div id="advisors" class="small">Welcome, Mayor! Lay roads, plop a power plant, zone R/C/I, then unpause.</div>
      </div>
      <div id="log"></div>
    </div>
  </div>

  <div id="help">
    <div class="card">
      <div style="display:flex; justify-content: space-between; align-items:center; gap:8px; margin-bottom: 6px;">
        <h2>Micropolis+ â€” Quick Help</h2>
        <button id="helpClose">Close</button>
      </div>
      <div class="small">Single-file city builder inspired by SimCity 2000. Includes a New Castle County, DE preset.</div>
      <h3>Goal</h3>
      <ul>
        <li>Provide power and water, build roads, zone Residential/Commercial/Industrial, and grow a thriving city.</li>
        <li>Balance budget via Taxes. Place services (Fire/Police/School/Park) to improve land value and safety.</li>
      </ul>
      <h3>Controls</h3>
      <ul>
        <li>Pan: drag with mouse. Zoom: mouse wheel. Reset camera: press R.</li>
        <li>Tool hotkeys: B Bulldoze, R Road, T Rail, L Power Lines, W Pipes, 1-3 R/C/I Zones, P Park, O Power Plant, U Water Pump, F Fire Station, C Police, S School, Q Query.</li>
        <li>Speed: top bar. New/Save/Load on the left. Click NCC Map for New Castle County. Toggle Music at the top.</li>
      </ul>
      <h3>Overlays</h3>
      <ul>
        <li>Power/Water: shows connectivity. Traffic: road usage heatmap. Pollution/Crime: darker = worse. Land Value: greener = better.</li>
      </ul>
      <h3>Tips</h3>
      <ul>
        <li>Zones need adjacent road and power to develop; water improves growth.</li>
        <li>Industrial raises pollution; parks and waterfront increase land value.</li>
        <li>Fires break out; fire stations help suppress. Bulldoze rubble.</li>
      </ul>
      <div class="small">Made with pure Canvas 2D. No external assets.</div>
    </div>
  </div>

  <script>
  ;(() => {
    const VERSION = 'v4.2';
    const SIZE = 96; // map tiles per side
    const TILE = 16; // base tile draw size at scale=1
    const SEA = 3;   // sea level height
    const DAY_SECONDS = 30; // real seconds per in-game day at 1x
    const START_MONEY = 20000;
    const MONTH_SECONDS = 12; // real seconds per in-game month at 1x

    const Tools = [
      { id: 'bulldoze', label: 'Bulldoze', key: 'b', cost: 1, icon: 'ðŸ§¨' },
      { id: 'raise', label: 'Raise Land', key: 'E', cost: 5, icon: 'â›°ï¸' },
      { id: 'lower', label: 'Lower Land', key: 'Q', cost: 5, icon: 'ðŸ•³ï¸' },
      { id: 'smooth', label: 'Smooth', key: 'G', cost: 10, icon: 'ðŸªµ' },
      { id: 'road', label: 'Road', key: 'r', cost: 10, icon: 'ðŸ›£ï¸' },
      { id: 'rail', label: 'Rail', key: 't', cost: 20, icon: 'ðŸš†' },
      { id: 'powerline', label: 'Power Line', key: 'l', cost: 5, icon: 'âš¡' },
      { id: 'pipe', label: 'Pipe', key: 'w', cost: 5, icon: 'ðŸš°' },
      { id: 'res', label: 'Residential', key: '1', cost: 100, icon: 'ðŸ ' },
      { id: 'com', label: 'Commercial', key: '2', cost: 120, icon: 'ðŸ¬' },
      { id: 'ind', label: 'Industrial', key: '3', cost: 80, icon: 'ðŸ­' },
      { id: 'park', label: 'Park', key: 'p', cost: 20, icon: 'ðŸŒ³' },
      { id: 'farm', label: 'Farm', key: 'm', cost: 60, icon: 'ðŸŒ¾' },
      { id: 'powerplant', label: 'Power Plant', key: 'o', cost: 3000, icon: 'ðŸ”‹' },
      { id: 'waterpump', label: 'Water Pump', key: 'u', cost: 1200, icon: 'ðŸ’§' },
      { id: 'fire', label: 'Fire Station', key: 'f', cost: 600, icon: 'ðŸš’' },
      { id: 'police', label: 'Police', key: 'c', cost: 600, icon: 'ðŸš“' },
      { id: 'school', label: 'School', key: 's', cost: 400, icon: 'ðŸ«' },
      { id: 'ranch', label: 'Ranch', key: 'h', cost: 120, icon: 'ðŸ„' },
      { id: 'forestry', label: 'Forestry', key: 'y', cost: 150, icon: 'ðŸŒ²' },
      { id: 'query', label: 'Query', key: 'q', cost: 0, icon: 'ðŸ”' },
    ];

    const T = {
      NONE: 0,
      ROAD: 1,
      RAIL: 2,
    };
    const U = {
      NONE: 0,
      POWER: 1,
      PIPE: 2,
    };

    const ZONE = {
      NONE: 0,
      RES: 1,
      COM: 2,
      IND: 3,
      PARK: 4,
      SPECIAL: 5, // power plant, etc.
      FARM: 6,
    };

    const SPECIAL = {
      NONE: 0,
      POWER_PLANT: 1,
      WATER_PUMP: 2,
      FIRE: 3,
      POLICE: 4,
      SCHOOL: 5,
      RANCH: 6,
      FORESTRY: 7,
    };

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rnd = (n=1) => Math.random()*n;
    const irnd = (n=1) => Math.floor(Math.random()*n);

    function makeTile() {
      return {
        h: 0,
        water: false,
        ocean: false,
        zone: ZONE.NONE,
        special: SPECIAL.NONE,
        b: 0,
        t: T.NONE,
        u: U.NONE,
        powered: false,
        watered: false,
        traffic: 0,
        fx: 0, fy: 0,
        pollution: 0,
        crime: 0,
        fire: 0,
        land: 0,
        trees: 0,
        moisture: 0,
        temp: 20,
      };
    }

    const world = {
      tiles: new Array(SIZE*SIZE).fill(0).map(makeTile),
      popR: 0, popC: 0, popI: 0,
      money: START_MONEY,
      infiniteMoney: false,
      month: 0,
      dayPhase: 0, // 0..1
      taxRate: 7.0,
      demandR: 0, demandC: 0, demandI: 0,
      powerCapacity: 0,
      waterCapacity: 0,
      speed: 1.0,
      eco: { o2: 21.0, co2: 0.04, food: 0, wood: 0 },
    };

    const cam = { x: SIZE*TILE/2, y: SIZE*TILE/2, scale: 2.0, dragging: false, lx:0, ly:0 };
    const time = { t: 0 };

    const ui = {
      tool: 'road', brush: 1, overlay: 'none', query: false,
      setTool(id){ this.tool = id; this.query = (id==='query'); renderTools(); },
      setOverlay(v){ this.overlay = v; },
      log(msg){ const el = document.getElementById('log'); const time = gameDate(); el.innerHTML = `<div>[${time}] ${msg}</div>` + el.innerHTML; },
      help: false,
      showHelp(){ document.getElementById('help').style.display='flex'; },
      hideHelp(){ document.getElementById('help').style.display='none'; },
    };
    // Expose for inline onclick in Help modal
    window.ui = ui;

    function idx(x,y){ return y*SIZE + x; }
    function inb(x,y){ return x>=0 && x<SIZE && y>=0 && y<SIZE; }
    function for4(x,y,fn){ fn(x+1,y); fn(x-1,y); fn(x,y+1); fn(x,y-1); }

    function gameDate(){ const year = 1900 + Math.floor(world.month/12); const m = world.month%12; const names = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']; return `${names[m]} ${year}`; }

    function seedMap() {
      // Diamond-square-ish simple fractal for height
      const h = new Float32Array(SIZE*SIZE);
      const put = (x,y,v)=>{ h[idx(x,y)] = v; };
      const get = (x,y)=> h[idx(clamp(x,0,SIZE-1), clamp(y,0,SIZE-1))];
      // start with random corners
      put(0,0,rnd(8)); put(SIZE-1,0,rnd(8)); put(0,SIZE-1,rnd(8)); put(SIZE-1,SIZE-1,rnd(8));
      let step = SIZE-1; let rough = 4;
      while(step>1){
        for(let y=0;y<SIZE-1;y+=step){
          for(let x=0;x<SIZE-1;x+=step){
            const m = (get(x,y)+get(x+step,y)+get(x,y+step)+get(x+step,y+step))/4 + (rnd(2)-1)*rough;
            put(x+step/2,y+step/2,m);
          }
        }
        for(let y=0;y<SIZE;y+=step/2){
          for(let x=(y%(step)===0? step/2:0); x<SIZE; x+=step){
            const v = (get(x-step/2,y)+get(x+step/2,y)+get(x,y-step/2)+get(x,y+step/2))/4 + (rnd(2)-1)*rough;
            put(x,y,v);
          }
        }
        step/=2; rough*=0.55;
      }
      // normalize
      let mn=1e9,mx=-1e9; for(let i=0;i<h.length;i++){ if(h[i]<mn) mn=h[i]; if(h[i]>mx) mx=h[i]; }
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t = world.tiles[idx(x,y)];
        const v = (h[idx(x,y)]-mn)/(mx-mn);
        t.h = Math.round(v*8);
        t.water = t.h <= SEA;
        t.ocean = false;
        t.zone = ZONE.NONE; t.special = SPECIAL.NONE; t.b=0; t.t=T.NONE; t.u=U.NONE; t.powered=false; t.watered=false; t.pollution=0; t.traffic=0; t.crime=0; t.fire=0; t.land=0;
      }
      // carve a river
      let rx = irnd(SIZE), ry=0; for(let i=0;i<SIZE*2;i++){ if(!inb(rx,ry)) break; const t=world.tiles[idx(rx,ry)]; t.h=SEA-1; t.water=true; ry++; rx += irnd(3)-1; rx=clamp(rx,1,SIZE-2);}      
      ui.log('New terrain generated.');
    }

    // New Castle County, Delaware preset (approximate):
    // East border is the Delaware River; Christina River delta near Wilmington;
    // C&D Canal crosses roughly east-west around mid-county.
    function seedNewCastle(){
      // baseline gentle hills north; flatter south
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t = world.tiles[idx(x,y)];
        const ny = y/SIZE; const nx = x/SIZE;
        let elev = 3 + Math.sin(nx*5)*0.8 + Math.cos(ny*4)*0.6 + (ny<0.35? (0.35-ny)*6 : 0);
        t.h = Math.round(clamp(elev,0,10));
        t.water = false; t.ocean=false; t.zone=ZONE.NONE; t.special=SPECIAL.NONE; t.b=0; t.t=T.NONE; t.u=U.NONE; t.powered=false; t.watered=false; t.pollution=0; t.traffic=0; t.crime=0; t.fire=0; t.land=0;
      }
      // Delaware River ribbon along the east with a curve/bay south
      for(let y=0;y<SIZE;y++){
        const ny = y/SIZE;
        const riverCenter = 0.80 - 0.08*Math.sin(ny*3.2);
        for(let x=Math.floor(SIZE*riverCenter); x<SIZE; x++){
          const t = world.tiles[idx(x,y)]; t.h = SEA-1; t.water = true;
        }
      }
      // Christina River arm near Wilmington (north-east quadrant)
      for(let i=0;i<60;i++){
        const y = Math.floor(12 + i*0.35);
        const x = Math.floor(64 - i*0.25 + Math.sin(i*0.2)*2);
        if(inb(x,y)){ const t=world.tiles[idx(x,y)]; t.h=SEA-1; t.water=true; }
        if(inb(x+1,y)){ const t=world.tiles[idx(x+1,y)]; t.h=SEA-1; t.water=true; }
      }
      // Chesapeake & Delaware Canal (roughly horizontal ~ middle)
      const cy = Math.floor(SIZE*0.55);
      for(let x=6;x<SIZE-6;x++){
        for(let dy=-1; dy<=1; dy++){
          const y = cy+dy; if(!inb(x,y)) continue; const t=world.tiles[idx(x,y)]; t.h=SEA-1; t.water=true;
        }
      }
      // Bridges across canal every ~20 tiles
      for(let bx=10; bx<SIZE-10; bx+=20){ for(let dy=-1; dy<=1; dy++){ const y=cy+dy; for(let dx=-1; dx<=1; dx++){ const x=bx+dx; if(!inb(x,y)) continue; const t=world.tiles[idx(x,y)]; t.t = t.t|T.ROAD; }} }
      // Set sea-level water expansion on low tiles touching water
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t=world.tiles[idx(x,y)];
        if(t.h<=SEA && !t.water){ let near=false; for4(x,y,(nx,ny)=>{ if(inb(nx,ny)&&world.tiles[idx(nx,ny)].water) near=true; }); if(near){ t.water=true; t.h=SEA-1; }}
      }
      // Starter infrastructure near Wilmington area and coherent arterial roads
      const pp = { x: 58, y: 18 };
      if(inb(pp.x,pp.y) && !world.tiles[idx(pp.x,pp.y)].water){ const t=world.tiles[idx(pp.x,pp.y)]; t.special=SPECIAL.POWER_PLANT; t.zone=ZONE.SPECIAL; }
      // Backup plant near mid-county (south-west of Wilmington)
      const pp2 = { x: 44, y: 30 };
      if(inb(pp2.x,pp2.y) && !world.tiles[idx(pp2.x,pp2.y)].water){ const t=world.tiles[idx(pp2.x,pp2.y)]; t.special=SPECIAL.POWER_PLANT; t.zone=ZONE.SPECIAL; }
      // Arterials: N-S and E-W grids around Wilmington
      for(let y=12;y<=28;y+=2){ for(let x=46;x<=68;x++){ if(!inb(x,y)) continue; const t=world.tiles[idx(x,y)]; if(!t.water) t.t = t.t|T.ROAD; } }
      for(let x=46;x<=68;x+=2){ for(let y=12;y<=28;y++){ if(!inb(x,y)) continue; const t=world.tiles[idx(x,y)]; if(!t.water) t.t = t.t|T.ROAD; } }
      // A north-south corridor toward the canal (approx US-13)
      for(let y=18;y<cy;y++){ const x=52; if(inb(x,y)){ const t=world.tiles[idx(x,y)]; t.t = t.t|T.ROAD; } }
      // Power trunk
      for(let y=pp.y; y<pp.y+10; y++){ const x=pp.x+2; if(inb(x,y)){ const t=world.tiles[idx(x,y)]; if(!t.water) t.u = t.u|U.POWER; }}
      // Water pump along canal
      const wp = { x: 40, y: cy-2 };
      if(inb(wp.x,wp.y) && !world.tiles[idx(wp.x,wp.y)].water){ const t=world.tiles[idx(wp.x,wp.y)]; t.special=SPECIAL.WATER_PUMP; t.zone=ZONE.SPECIAL; }
      for(let x=28;x<=52;x++){ const y=cy-2; if(!inb(x,y)) continue; const t=world.tiles[idx(x,y)]; if(!t.water) t.u = t.u|U.PIPE; }
      // A few seed zones
      const seedZones = [ [52,20,ZONE.RES], [54,20,ZONE.RES], [50,22,ZONE.COM], [56,22,ZONE.IND], [60,20,ZONE.RES] ];
      seedZones.forEach(([x,y,z])=>{ if(inb(x,y)){ const t=world.tiles[idx(x,y)]; if(!t.water){ t.zone = z; t.b = 0; } } });
      ui.log('New Castle County map generated.');
    }

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // UI setup
    function renderTools(){
      const cont = document.getElementById('tools');
      cont.innerHTML = '';
      Tools.forEach(t => {
        const div = document.createElement('div');
        div.className = 'tool' + (ui.tool===t.id? ' active':'');
        div.innerHTML = `<div class="ico">${t.icon||''}</div><div class=\"lbl\">${t.label}</div>`;
        div.title = `${t.label} ($${t.cost}) â€” key: ${t.key.toUpperCase()}`;
        div.onclick = ()=>{ ui.setTool(t.id); updateCostPreview(); };
        cont.appendChild(div);
      });
    }

    function resize(){
      const dpr = window.devicePixelRatio || 1;
      const w = canvas.clientWidth = canvas.parentElement.clientWidth;
      const h = canvas.clientHeight = canvas.parentElement.clientHeight;
      canvas.width = Math.floor(w*dpr);
      canvas.height = Math.floor(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', resize);

    function worldToScreen(tx,ty){
      return [ (tx*TILE - cam.x)*cam.scale + canvas.clientWidth/2,
               (ty*TILE - cam.y)*cam.scale + canvas.clientHeight/2 ];
    }
    function screenToTile(px,py){
      const x = (px - canvas.clientWidth/2)/cam.scale + cam.x;
      const y = (py - canvas.clientHeight/2)/cam.scale + cam.y;
      return [Math.floor(x/TILE), Math.floor(y/TILE)];
    }

    // Drawing helpers
    function drawRect(x,y,w,h,c){ ctx.fillStyle=c; ctx.fillRect(x,y,w,h); }
    function drawTile(x,y,fill,stroke){ const [sx,sy]=worldToScreen(x,y); const s=TILE*cam.scale; ctx.fillStyle=fill; ctx.fillRect(sx,sy,s,s); if(stroke){ ctx.strokeStyle=stroke; ctx.strokeRect(sx+0.5,sy+0.5,s-1,s-1);} }
    function colLerp(a,b,t){ const pa=parseInt(a.slice(1),16), pb=parseInt(b.slice(1),16); const r=Math.round(((pa>>16)&255)*(1-t)+((pb>>16)&255)*t); const g=Math.round(((pa>>8)&255)*(1-t)+((pb>>8)&255)*t); const bl=Math.round((pa&255)*(1-t)+((pb&255))*t); return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${bl.toString(16).padStart(2,'0')}`; }

    const particles = [];
    const birds = [];
    const boats = [];
    const shipwrecks = [];
    function spawnWreck(sx,sy,rot){ shipwrecks.push({ x:sx, y:sy, r:rot, a:1.0 }); if(shipwrecks.length>60) shipwrecks.shift(); }
    function spawnBoat(){
      // choose an ocean tile near shore in view
      const [minx,miny] = screenToTile(0,0); const [maxx,maxy] = screenToTile(canvas.clientWidth,canvas.clientHeight);
      for(let tries=0; tries<60; tries++){
        const x = clamp(irnd(maxx-minx)+minx, 2, SIZE-3);
        const y = clamp(irnd(maxy-miny)+miny, 2, SIZE-3);
        const t = world.tiles[idx(x,y)]; if(!t.ocean) continue; let near=false; for4(x,y,(nx,ny)=>{ if(inb(nx,ny)&&!world.tiles[idx(nx,ny)].water) near=true; }); if(!near) continue;
        // wind for direction
        const wx = 0.9 + 0.2*Math.sin(y*0.08 + time.t*0.2); const wy = 0.1 + 0.2*Math.sin(x*0.06 - time.t*0.15); const wl=Math.hypot(wx,wy)||1;
        boats.push({ x:x+0.5, y:y+0.5, vx:(wx/wl)*0.2, vy:(wy/wl)*0.2, a:1.0, r:0 });
        break;
      }
    }
    function spawnBird(){
      // find a coastline y around current view
      const [minx,miny] = screenToTile(0,0); const [maxx,maxy] = screenToTile(canvas.clientWidth,canvas.clientHeight);
      for(let tries=0; tries<40; tries++){
        const x = clamp(irnd(maxx-minx)+minx, 1, SIZE-2);
        const y = clamp(irnd(maxy-miny)+miny, 1, SIZE-2);
        const t = world.tiles[idx(x,y)];
        if(t.ocean){ let nearLand=false; for4(x,y,(nx,ny)=>{ if(inb(nx,ny)&&!world.tiles[idx(nx,ny)].water) nearLand=true; }); if(nearLand){ const [sx,sy]=worldToScreen(x,y); birds.push({ x:sx, y:sy-10, vx: 0.6+Math.random()*0.6, vy: -0.05+Math.random()*0.1, t:0}); break; } }
      }
    }
    function spawnFireworks(){
      const make = (x,y)=>{
        for(let i=0;i<50;i++){
          const a = Math.random()*Math.PI*2; const sp = 0.8+Math.random()*1.6;
          particles.push({ x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp-0.5, a: 1.0, r: 1.5+Math.random()*1.5, color: ['#ff6b6b','#ffd36a','#6bc0ff','#b56bff'][i%4], g: 0.03 });
        }
      };
      // Spawn 3-4 shows around the current view
      const [minx,miny] = screenToTile(0,0); const [maxx,maxy] = screenToTile(canvas.clientWidth,canvas.clientHeight);
      for(let k=0;k<4;k++){
        const tx = clamp(irnd(maxx-minx)+minx, 0, SIZE-1); const ty = clamp(irnd(maxy-miny)+miny, 0, SIZE-1);
        const [sx,sy] = worldToScreen(tx+0.5, ty+0.4);
        make(sx, sy);
      }
    }
    function render(){
      const anim = Math.max(0, world.speed/10);
      ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
      const s = TILE*cam.scale;
      const [minx,miny] = screenToTile(0,0);
      const [maxx,maxy] = screenToTile(canvas.clientWidth,canvas.clientHeight);
      const ax = clamp(minx-1,0,SIZE-1), bx = clamp(maxx+1,0,SIZE-1);
      const ay = clamp(miny-1,0,SIZE-1), by = clamp(maxy+1,0,SIZE-1);
      // terrain
      for(let y=ay;y<=by;y++){
        for(let x=ax;x<=bx;x++){
          const t = world.tiles[idx(x,y)];
          const wave = (Math.sin((x+y+time.t*0.5)*0.6)+1)/2*0.05;
          let base;
          if(t.water){
            if(t.ocean){ base = colLerp('#113a59','#0c2238', wave); }
            else { base = '#17324a'; }
          } else {
            base = colLerp('#2b4c2b','#203a20', t.h/10);
          }
          drawTile(x,y,base);
        }
      }
      // beaches and coast highlights
      for(let y=ay;y<=by;y++){
        for(let x=ax;x<=bx;x++){
          const t = world.tiles[idx(x,y)];
          if(!t.water){
            // draw sand strips on edges bordering water
            let edgeW=false, edgeE=false, edgeN=false, edgeS=false; 
            const chk=(nx,ny)=> inb(nx,ny) && world.tiles[idx(nx,ny)].water;
            edgeW = chk(x-1,y); edgeE = chk(x+1,y); edgeN = chk(x,y-1); edgeS = chk(x,y+1);
            const [sx,sy]=worldToScreen(x,y); const ssz = s; ctx.fillStyle='#d7c79e';
            if(edgeN) ctx.fillRect(sx, sy, ssz, Math.max(2, ssz*0.12));
            if(edgeS) ctx.fillRect(sx, sy+ssz-Math.max(2, ssz*0.12), ssz, Math.max(2, ssz*0.12));
            if(edgeW) ctx.fillRect(sx, sy, Math.max(2, ssz*0.12), ssz);
            if(edgeE) ctx.fillRect(sx+ssz-Math.max(2, ssz*0.12), sy, Math.max(2, ssz*0.12), ssz);
          }
        }
      }
      // ocean whitecaps + shore foam
      for(let y=ay;y<=by;y++){
        for(let x=ax;x<=bx;x++){
          const t = world.tiles[idx(x,y)]; if(!t.ocean) continue; const [sx,sy]=worldToScreen(x,y); const ssz=s;
          // wind field
          const wind = windAt(x,y);
          // adjust near coast to push waves towards shore
          let near=false; let nxv=0, nyv=0; for4(x,y,(nx,ny)=>{ if(!inb(nx,ny)) return; if(!world.tiles[idx(nx,ny)].water){ near=true; nxv += nx-x; nyv += ny-y; } });
          let dir = wind; if(near){ const nl = Math.hypot(nxv,nyv)||1; dir = [(wind[0]*0.6 + (nxv/nl)*0.4), (wind[1]*0.6 + (nyv/nl)*0.4)]; const dl=Math.hypot(dir[0],dir[1])||1; dir=[dir[0]/dl, dir[1]/dl]; }
          // fewer whitecaps, marching along dir
          const kx = dir[0]*0.9, ky = dir[1]*0.9; const phase = (x*kx + y*ky + time.t*0.8) % 1.0;
          if(phase < 0.05 && ((x+y)%4===0)){ ctx.globalAlpha=0.22; ctx.strokeStyle='#eef6ff'; ctx.lineWidth = Math.max(1, ssz*0.06); ctx.beginPath(); // crest perpendicular to dir
            const px = -dir[1], py = dir[0]; const cx = sx+ssz/2, cy = sy+ssz/2; ctx.moveTo(cx - px*ssz*0.5, cy - py*ssz*0.5); ctx.lineTo(cx + px*ssz*0.5, cy + py*ssz*0.5); ctx.stroke(); ctx.globalAlpha=1; }
          // foam at coast based on impact angle
          if(near){ const impact = Math.max(0, dir[0]*nxv + dir[1]*nyv)/Math.max(1, Math.hypot(nxv,nyv)); const w = Math.max(1, ssz*0.08*(1+Math.sin(time.t*1.5 + (x+y)*0.2))*impact); ctx.globalAlpha=0.3; ctx.fillStyle='#eef6ff'; if(nxv<0) ctx.fillRect(sx, sy, Math.max(2,w), ssz); if(nxv>0) ctx.fillRect(sx+ssz-Math.max(2,w), sy, Math.max(2,w), ssz); if(nyv<0) ctx.fillRect(sx, sy, ssz, Math.max(2,w)); if(nyv>0) ctx.fillRect(sx, sy+ssz-Math.max(2,w), ssz, Math.max(2,w)); ctx.globalAlpha=1; }
        }
      }
      // grids (light)
      ctx.globalAlpha=0.08; ctx.strokeStyle='#ffffff';
      for(let x=ax;x<=bx;x++){ const [sx] = worldToScreen(x,0); ctx.beginPath(); ctx.moveTo(Math.round(sx)+0.5,0); ctx.lineTo(Math.round(sx)+0.5,canvas.clientHeight); ctx.stroke(); }
      for(let y=ay;y<=by;y++){ const [,sy] = worldToScreen(0,y); ctx.beginPath(); ctx.moveTo(0,Math.round(sy)+0.5); ctx.lineTo(canvas.clientWidth,Math.round(sy)+0.5); ctx.stroke(); }
      ctx.globalAlpha=1;

      // utilities, transport, zones/buildings
      for(let y=ay;y<=by;y++){
        for(let x=ax;x<=bx;x++){
          const t = world.tiles[idx(x,y)];
          const [sx,sy]=worldToScreen(x,y); const ssz = s;
          if(t.t & T.ROAD){
            // draw rounded road segments based on neighbors
            ctx.lineWidth = Math.max(2, ssz*0.28); ctx.lineCap='round'; ctx.lineJoin='round';
            const cx = sx+ssz/2, cy = sy+ssz/2; 
            const nN = inb(x,y-1) && (world.tiles[idx(x,y-1)].t & T.ROAD);
            const nS = inb(x,y+1) && (world.tiles[idx(x,y+1)].t & T.ROAD);
            const nW = inb(x-1,y) && (world.tiles[idx(x-1,y)].t & T.ROAD);
            const nE = inb(x+1,y) && (world.tiles[idx(x+1,y)].t & T.ROAD);
            ctx.strokeStyle = '#60646a';
            ctx.beginPath(); ctx.moveTo(cx,cy);
            if(nN) { ctx.moveTo(cx,cy); ctx.lineTo(cx, sy); }
            if(nS) { ctx.moveTo(cx,cy); ctx.lineTo(cx, sy+ssz); }
            if(nW) { ctx.moveTo(cx,cy); ctx.lineTo(sx, cy); }
            if(nE) { ctx.moveTo(cx,cy); ctx.lineTo(sx+ssz, cy); }
            if(!nN&&!nS&&!nW&&!nE){ ctx.moveTo(sx+ssz*0.2,cy); ctx.lineTo(sx+ssz*0.8,cy); }
            ctx.stroke();
            // marching ants traffic overlay: horizontal and vertical segments, offset by flow sign
            const dash = [ssz*0.35, ssz*0.35];
            ctx.setLineDash(dash);
            ctx.lineWidth = Math.max(1, ssz*0.12);
            const flowH = t.fx; const flowV = t.fy;
            const antsSpeed = 2.0;
            if(nW||nE){ ctx.strokeStyle = '#8ea6b8'; ctx.lineDashOffset = (time.t*antsSpeed * (flowH>=0? -1:1))*ssz; ctx.beginPath(); if(nW){ ctx.moveTo(sx, cy); ctx.lineTo(cx, cy); } if(nE){ ctx.moveTo(cx, cy); ctx.lineTo(sx+ssz, cy); } ctx.stroke(); }
            if(nN||nS){ ctx.strokeStyle = '#8ea6b8'; ctx.lineDashOffset = (time.t*antsSpeed * (flowV>=0? -1:1))*ssz; ctx.beginPath(); if(nN){ ctx.moveTo(cx, sy); ctx.lineTo(cx, cy); } if(nS){ ctx.moveTo(cx, cy); ctx.lineTo(cx, sy+ssz); } ctx.stroke(); }
            // directional arrow at center
            const mag = Math.hypot(flowH, flowV);
            if(mag>3){ const vx = (flowH/mag), vy=(flowV/mag); ctx.setLineDash([]); ctx.strokeStyle='#bcd0df'; ctx.lineWidth = Math.max(1, ssz*0.08); ctx.beginPath(); ctx.moveTo(cx - vx*ssz*0.15, cy - vy*ssz*0.15); ctx.lineTo(cx + vx*ssz*0.15, cy + vy*ssz*0.15); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx + vx*ssz*0.15, cy + vy*ssz*0.15); ctx.lineTo(cx + vx*ssz*0.15 - vy*ssz*0.08, cy + vy*ssz*0.15 + vx*ssz*0.08); ctx.lineTo(cx + vx*ssz*0.15 + vy*ssz*0.08, cy + vy*ssz*0.15 - vx*ssz*0.08); ctx.fillStyle='#bcd0df'; ctx.fill(); }
            ctx.setLineDash([]);
          }
          if(t.t & T.RAIL){ ctx.fillStyle = '#7b5d2e'; ctx.fillRect(sx+ssz*0.45,sy,ssz*0.1,ssz); ctx.fillRect(sx,sy+ssz*0.45,ssz,ssz*0.1); }
          if(t.u & U.POWER){ ctx.strokeStyle = '#ffd34d'; ctx.beginPath(); ctx.moveTo(sx+2,sy+2); ctx.lineTo(sx+ssz-2,sy+ssz-2); ctx.moveTo(sx+ssz-2,sy+2); ctx.lineTo(sx+2,sy+ssz-2); ctx.stroke(); }
          if(t.u & U.PIPE){ ctx.strokeStyle = '#55aaff'; ctx.strokeRect(sx+3,sy+3,ssz-6,ssz-6); }
          if(t.zone!==ZONE.NONE || t.special!==SPECIAL.NONE){
            let col = '#6aa867';
            if(t.zone===ZONE.RES) col = ['#6aa867','#5c9a59','#458243'][t.b]||'#6aa867';
            if(t.zone===ZONE.COM) col = ['#6a86a8','#5c789a','#3e5d84'][t.b]||'#6a86a8';
            if(t.zone===ZONE.IND) col = ['#a8a06a','#9a905c','#847e3e'][t.b]||'#a8a06a';
            if(t.zone===ZONE.PARK) col = '#2fa24f';
            if(t.zone===ZONE.FARM) col = ['#a67c52','#b68c62','#c69c72'][t.b]||'#a67c52';
            if(t.special!==SPECIAL.NONE) col = '#a86a6a';
            // growth animation pulse
            let inset = 2; if(t.grow && t.grow>0){ inset = 2 + Math.sin(time.t*10)*1.2; t.grow = Math.max(0, t.grow - 0.02); }
            ctx.fillStyle = col; ctx.fillRect(sx+inset,sy+inset,ssz-inset*2,ssz-inset*2);
            if(t.special===SPECIAL.POWER_PLANT){ ctx.fillStyle='#ffef70'; ctx.fillRect(sx+ssz*0.2,sy+ssz*0.2,ssz*0.6,ssz*0.6);} 
            if(t.special===SPECIAL.WATER_PUMP){ ctx.fillStyle='#6bc0ff'; ctx.beginPath(); ctx.arc(sx+ssz/2, sy+ssz/2, ssz*0.35, 0, Math.PI*2); ctx.fill(); }
            if(t.special===SPECIAL.FIRE){ ctx.fillStyle='#ff6b6b'; ctx.fillRect(sx+ssz*0.25,sy+ssz*0.25,ssz*0.5,ssz*0.5);} 
            if(t.special===SPECIAL.POLICE){ ctx.fillStyle='#6b8bff'; ctx.fillRect(sx+ssz*0.25,sy+ssz*0.25,ssz*0.5,ssz*0.5);} 
            if(t.special===SPECIAL.SCHOOL){ ctx.fillStyle='#f7c36a'; ctx.fillRect(sx+ssz*0.25,sy+ssz*0.25,ssz*0.5,ssz*0.5);} 
            if(t.special===SPECIAL.RANCH){ ctx.fillStyle='#d8c8a8'; ctx.fillRect(sx+ssz*0.25,sy+ssz*0.25,ssz*0.5,ssz*0.5); }
            if(t.special===SPECIAL.FORESTRY){ ctx.fillStyle='#2b6a3a'; ctx.fillRect(sx+ssz*0.25,sy+ssz*0.25,ssz*0.5,ssz*0.5); }
            // simple smoke from active industry
            if(t.zone===ZONE.IND && t.b>0 && Math.random()<0.05){ particles.push({ x:sx+ssz*0.5+Math.random()*6-3, y:sy+ssz*0.2, vx:(Math.random()-0.5)*0.2, vy:-0.3-Math.random()*0.2, a:0.6, r:1.5+Math.random()*2 }); }
          }
          // draw forest trees as dots on empty land
          if(!t.water && t.zone===ZONE.NONE && t.trees>5){ const n = Math.min(4, Math.floor(t.trees/20)); ctx.fillStyle='#1f6a2c'; for(let k=0;k<n;k++){ ctx.beginPath(); ctx.arc(sx+3+3*k, sy+ssz-4-2*k, 2, 0, Math.PI*2); ctx.fill(); } }
          // fires overlay visual
          if(t.fire>0){ ctx.globalAlpha = clamp(t.fire/100, 0.2, 0.9); ctx.fillStyle = '#ff3b1a'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
        }
      }

      // particles
      for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx*anim; p.y+=p.vy*anim; if(p.g){ p.vy += p.g*anim; } p.a-=0.012*anim; p.r+=0.01*anim; if(p.a<=0){ particles.splice(i,1); continue; } ctx.globalAlpha = Math.max(0, p.a); ctx.fillStyle=p.color||'#9a9a9a'; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
      // boats
      for(let i=boats.length-1;i>=0;i--){ const b=boats[i];
        // follow wind, tack slightly
        const w = windAt(Math.floor(b.x), Math.floor(b.y)); const angle = Math.atan2(w[1], w[0]); const tack = (b.tb||1); const targetAngle = angle + (tack*Math.PI/3)* (Math.random()<0.02? (b.tb*=-1,1):1);
        const speed = 0.12; const tx = Math.cos(targetAngle)*speed, ty = Math.sin(targetAngle)*speed;
        b.vx = b.vx*0.9 + tx*0.1; b.vy = b.vy*0.9 + ty*0.1;
        const vmax = 0.2; const vm = Math.hypot(b.vx,b.vy); if(vm>vmax){ b.vx*=vmax/vm; b.vy*=vmax/vm; }
        b.x+=b.vx*anim; b.y+=b.vy*anim;
        // draw semicircle hull facing motion
        const [sx,sy]=worldToScreen(b.x, b.y); const heading = Math.atan2(b.vy, b.vx); const r=5;
        ctx.save(); ctx.translate(sx,sy); ctx.rotate(heading);
        ctx.fillStyle='#fdf9f3'; ctx.beginPath(); ctx.arc(0,0,r, Math.PI/2, -Math.PI/2, true); ctx.lineTo(-r, r); ctx.lineTo(-r, -r); ctx.closePath(); ctx.fill();
        ctx.restore();
        // wreck conditions
        const ix=Math.floor(b.x), iy=Math.floor(b.y); const inbnd=inb(ix,iy);
        const hitLand = inbnd && !world.tiles[idx(ix,iy)].ocean;
        const rareAtSea = Math.random() < 0.00002*anim;
        if(!inbnd || hitLand || rareAtSea){
          spawnWreck(sx, sy, heading + Math.PI);
          boats.splice(i,1);
        }
      }
      // birds
      for(let i=birds.length-1;i>=0;i--){ const b=birds[i]; b.x+=b.vx*anim; b.y+=b.vy*anim; b.t+=0.2*anim; const wing = Math.sin(b.t)*3; ctx.strokeStyle='#ffffff'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.moveTo(b.x-4, b.y); ctx.quadraticCurveTo(b.x-2, b.y-wing, b.x, b.y); ctx.quadraticCurveTo(b.x+2, b.y-wing, b.x+4, b.y); ctx.stroke(); if(b.x > canvas.clientWidth+20) birds.splice(i,1); }
      // shipwrecks
      for(let i=shipwrecks.length-1;i>=0;i--){ const w=shipwrecks[i]; ctx.save(); ctx.translate(w.x,w.y); ctx.rotate(w.r); ctx.globalAlpha = w.a; ctx.fillStyle='#7a5a3a'; ctx.fillRect(-6,-2,12,4); ctx.fillStyle='#3a2a1a'; ctx.fillRect(-2,-4,4,2); ctx.restore(); w.a = Math.max(0.2, w.a - 0.0005*anim); }

      // overlay heatmaps
      if(ui.overlay!=='none'){
        for(let y=ay;y<=by;y++){
          for(let x=ax;x<=bx;x++){
            const t = world.tiles[idx(x,y)];
            const [sx,sy]=worldToScreen(x,y); const ssz=s;
            if(ui.overlay==='power' && t.powered){ ctx.globalAlpha=0.2; ctx.fillStyle='#ffd34d'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
            if(ui.overlay==='water' && t.watered){ ctx.globalAlpha=0.2; ctx.fillStyle='#55aaff'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
            if(ui.overlay==='traffic'){ const v = clamp(t.traffic/50,0,1); if(v>0){ ctx.globalAlpha = clamp(v*0.7,0.1,0.7); ctx.fillStyle='#ff7b3b'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; } }
            if(ui.overlay==='pollution'){ const v = clamp(t.pollution/100,0,1); if(v>0){ ctx.globalAlpha = clamp(v*0.7,0.1,0.7); ctx.fillStyle='#8a8a8a'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; } }
            if(ui.overlay==='crime'){ const v = clamp(t.crime/100,0,1); if(v>0){ ctx.globalAlpha = clamp(v*0.7,0.1,0.7); ctx.fillStyle='#c43b7a'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; } }
            if(ui.overlay==='land'){ const v = clamp((t.land+50)/100,0,1); ctx.globalAlpha = 0.25; ctx.fillStyle = colLerp('#8a1a1a', '#1a8a2a', v); ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
            if(ui.overlay==='zones'){
              if(t.zone===ZONE.RES){ ctx.globalAlpha=0.25; ctx.fillStyle='#6aa867'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
              if(t.zone===ZONE.COM){ ctx.globalAlpha=0.25; ctx.fillStyle='#6a86a8'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
              if(t.zone===ZONE.IND){ ctx.globalAlpha=0.25; ctx.fillStyle='#a8a06a'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
              if(t.zone===ZONE.PARK){ ctx.globalAlpha=0.25; ctx.fillStyle='#2fa24f'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
              if(t.special!==SPECIAL.NONE){ ctx.globalAlpha=0.25; ctx.fillStyle='#a86a6a'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
            }
            if(ui.overlay==='fire' && t.fire>0){ ctx.globalAlpha = clamp(t.fire/100,0.2,0.9); ctx.fillStyle='#ff3b1a'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
            if(ui.overlay==='moisture'){ const v = clamp(t.moisture,0,1); if(v>0){ ctx.globalAlpha=0.25; ctx.fillStyle=colLerp('#0b1f2e','#4db4ff', v); ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; } }
            if(ui.overlay==='temp'){ const v = clamp((t.temp-0)/40,0,1); ctx.globalAlpha=0.25; ctx.fillStyle=colLerp('#1e3a8a','#ef4444', v); ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
            if(ui.overlay==='forest'){ const v = clamp(t.trees/100,0,1); if(v>0){ ctx.globalAlpha=0.25; ctx.fillStyle=colLerp('#1b3a1b', '#2fa24f', v); ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; } }
            if(ui.overlay==='o2'){ const v = clamp(world.eco.o2/25,0,1); ctx.globalAlpha=0.2; ctx.fillStyle='#7cecf4'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
            if(ui.overlay==='co2'){ const v = clamp(world.eco.co2/0.2,0,1); ctx.globalAlpha=0.2; ctx.fillStyle='#b57ce9'; ctx.fillRect(sx,sy,ssz,ssz); ctx.globalAlpha=1; }
          }
        }
      }

      // Night/day tint
      const dayL = 0.7 + 0.3*Math.max(0, Math.cos(world.dayPhase*2*Math.PI));
      if(dayL<0.99){ ctx.fillStyle = `rgba(0,0,0,${clamp(1-dayL,0,0.6)})`; ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight); }

      // HUD
      if(hoverTile){ const [hx,hy]=hoverTile; if(inb(hx,hy)){
        const b = ui.brush; const [sx,sy]=worldToScreen(hx,hy); const [sx2,sy2]=worldToScreen(hx+b, hy+b);
        ctx.strokeStyle='#50e3c2'; ctx.globalAlpha=0.8; ctx.strokeRect(sx+0.5,sy+0.5,(sx2-sx)-1,(sy2-sy)-1); ctx.globalAlpha=1;
      }}
      if(painting && currentDrag){ const [ax1,ay1]=currentDrag[0], [ax2,ay2]=currentDrag[1]; const x1=Math.min(ax1,ax2), y1=Math.min(ay1,ay2), x2=Math.max(ax1,ax2), y2=Math.max(ay1,ay2); const [sx,sy]=worldToScreen(x1,y1); const [sx2,sy2]=worldToScreen(x2+1,y2+1); ctx.strokeStyle='#50e3c2'; ctx.strokeRect(sx+0.5,sy+0.5,(sx2-sx)-1,(sy2-sy)-1); }

      requestAnimationFrame(render);
    }

    // Simulation
    function computePower() {
      world.powerCapacity = 0;
      const powered = new Uint8Array(SIZE*SIZE);
      const qx=[], qy=[];
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t=world.tiles[idx(x,y)];
        if(t.special===SPECIAL.POWER_PLANT){ world.powerCapacity += 5000; powered[idx(x,y)]=1; qx.push(x); qy.push(y); }
      }
      while(qx.length){
        const x=qx.shift(), y=qy.shift();
        const i=idx(x,y); powered[i]=1;
        for4(x,y,(nx,ny)=>{ if(!inb(nx,ny)) return; const nt=world.tiles[idx(nx,ny)]; if(powered[idx(nx,ny)]) return; if((nt.u&U.POWER) || nt.zone!==ZONE.NONE || nt.special!==SPECIAL.NONE){ powered[idx(nx,ny)]=1; qx.push(nx); qy.push(ny); } });
      }
      for(let i=0;i<powered.length;i++){ world.tiles[i].powered = !!powered[i]; }
    }

    function computeWater(){
      world.waterCapacity = 0;
      const watered = new Uint8Array(SIZE*SIZE);
      const qx=[], qy=[];
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t=world.tiles[idx(x,y)];
        if(t.special===SPECIAL.WATER_PUMP){ world.waterCapacity += 3000; watered[idx(x,y)]=1; qx.push(x); qy.push(y); }
      }
      while(qx.length){
        const x=qx.shift(), y=qy.shift();
        for4(x,y,(nx,ny)=>{ if(!inb(nx,ny)) return; const nt=world.tiles[idx(nx,ny)]; if(watered[idx(nx,ny)]) return; if(nt.u&U.PIPE){ watered[idx(nx,ny)]=1; qx.push(nx); qy.push(ny); } });
      }
      for(let i=0;i<watered.length;i++){ world.tiles[i].watered = !!watered[i]; }
    }

    function computeOcean(){
      // mark all water connected to map edges as ocean
      const ocean = new Uint8Array(SIZE*SIZE);
      const qx=[], qy=[];
      for(let x=0;x<SIZE;x++){
        if(world.tiles[idx(x,0)].water){ ocean[idx(x,0)]=1; qx.push(x); qy.push(0); }
        if(world.tiles[idx(x,SIZE-1)].water){ ocean[idx(x,SIZE-1)]=1; qx.push(x); qy.push(SIZE-1); }
      }
      for(let y=0;y<SIZE;y++){
        if(world.tiles[idx(0,y)].water){ ocean[idx(0,y)]=1; qx.push(0); qy.push(y); }
        if(world.tiles[idx(SIZE-1,y)].water){ ocean[idx(SIZE-1,y)]=1; qx.push(SIZE-1); qy.push(y); }
      }
      while(qx.length){
        const x=qx.shift(), y=qy.shift();
        for4(x,y,(nx,ny)=>{ if(!inb(nx,ny)) return; const i=idx(nx,ny); if(ocean[i]) return; const nt=world.tiles[i]; if(nt.water){ ocean[i]=1; qx.push(nx); qy.push(ny); } });
      }
      for(let i=0;i<world.tiles.length;i++){ world.tiles[i].ocean = !!ocean[i]; }
    }

    function computeLandValue(){
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t=world.tiles[idx(x,y)];
        let v = 0;
        // near water and parks increase
        let nearWater=0, parks=0, services=0;
        for(let dy=-3;dy<=3;dy++) for(let dx=-3;dx<=3;dx++){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const nt=world.tiles[idx(nx,ny)]; if(nt.water) nearWater++; if(nt.zone===ZONE.PARK) parks++; if(nt.special===SPECIAL.SCHOOL||nt.special===SPECIAL.POLICE||nt.special===SPECIAL.FIRE) services++; }
        v += nearWater*0.2 + parks*0.6 + services*0.5;
        v -= world.tiles[idx(x,y)].pollution*0.2 + world.tiles[idx(x,y)].crime*0.2;
        v -= world.tiles[idx(x,y)].traffic*0.1;
        world.tiles[idx(x,y)].land = clamp(Math.round(v), -50, 50);
      }
    }

    function hasRoadAdj(x,y){ let ok=false; for4(x,y,(nx,ny)=>{ if(inb(nx,ny) && (world.tiles[idx(nx,ny)].t&T.ROAD)) ok=true; }); return ok; }

    function developZones(){
      world.popR = world.popC = world.popI = 0;
      let jobsC=0,jobsI=0, homes=0;
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t=world.tiles[idx(x,y)];
        if(t.zone===ZONE.RES){ homes += (t.b+1)*8; world.popR += (t.b+1)*6; }
        if(t.zone===ZONE.COM){ jobsC += (t.b+1)*6; world.popC += (t.b+1)*4; }
        if(t.zone===ZONE.IND){ jobsI += (t.b+1)*10; world.popI += (t.b+1)*6; }
      }
      const jobs = jobsC + jobsI;
      const pop = world.popR + world.popC + world.popI;
      world.demandR = clamp(Math.round((jobs - pop)*0.02 - (world.taxRate-7)*2), -50, 50);
      world.demandC = clamp(Math.round((pop - jobsC)*0.02 - (world.taxRate-7)*2), -50, 50);
      world.demandI = clamp(Math.round((pop - jobsI)*0.02 - (world.taxRate-7)*2), -50, 50);

      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t=world.tiles[idx(x,y)];
        if(t.zone===ZONE.RES || t.zone===ZONE.COM || t.zone===ZONE.IND){
          const demand = t.zone===ZONE.RES? world.demandR : (t.zone===ZONE.COM? world.demandC : world.demandI);
          const desirability = demand + t.land + (t.powered?10:-20) + (t.watered?5:0) + (hasRoadAdj(x,y)?8:-30) - (t.pollution*0.3) - (t.crime*0.3);
          if(desirability > 10 && t.b<2 && Math.random()<0.4){ t.b++; t.grow = 1.0; }
          if(desirability < -10 && t.b>0 && Math.random()<0.3){ t.b--; t.grow = 1.0; }
        }
      }
    }

    function simulateTraffic(){
      for(let i=0;i<world.tiles.length;i++){ world.tiles[i].traffic *= 0.75; world.tiles[i].fx*=0.8; world.tiles[i].fy*=0.8; }
      const isJob = (x,y)=>{ const t=world.tiles[idx(x,y)]; return (t.zone===ZONE.COM||t.zone===ZONE.IND) && t.b>0; };
      const maxRadius = 28;
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t=world.tiles[idx(x,y)]; if(t.zone!==ZONE.RES || t.b===0) continue; if(!hasRoadAdj(x,y)) continue;
        const visited = new Uint8Array(SIZE*SIZE);
        const q=[]; const start = idx(x,y); q.push(start); visited[start]=1; const parent = new Int32Array(SIZE*SIZE); parent.fill(-1);
        let foundIdx=-1; let steps=0;
        while(q.length && steps<maxRadius){
          const cur = q.shift(); const cx = cur%SIZE, cy = Math.floor(cur/SIZE);
          if(world.tiles[cur].t & T.ROAD){
            let jobNear=false;
            for4(cx,cy,(nx,ny)=>{ if(!inb(nx,ny)) return; if(isJob(nx,ny)) jobNear=true; });
            if(jobNear){ foundIdx = cur; break; }
          }
          for4(cx,cy,(nx,ny)=>{ if(!inb(nx,ny)) return; const ni=idx(nx,ny); if(visited[ni]) return; if((world.tiles[ni].t & T.ROAD) || ni===start){ visited[ni]=1; parent[ni]=cur; q.push(ni); } });
          steps++;
        }
        if(foundIdx>=0){
          let cur = foundIdx; let count=0;
          while(parent[cur] !== -1 && count<maxRadius){
            const p = parent[cur];
            const cx = cur%SIZE, cy = Math.floor(cur/SIZE);
            const px = p%SIZE, py = Math.floor(p/SIZE);
            const dx = cx-px, dy = cy-py;
            world.tiles[cur].traffic += 4; 
            world.tiles[cur].fx += dx*2; world.tiles[cur].fy += dy*2; // accumulate directional flow
            cur = p; count++;
          }
        }
      }
    }

    function simulateExternalities(){
      for(let i=0;i<world.tiles.length;i++){ const t=world.tiles[i]; t.pollution *= 0.9; t.crime *= 0.9; t.fire = Math.max(0, t.fire-0.5); }
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t=world.tiles[idx(x,y)];
        if(t.zone===ZONE.IND){ t.pollution += 2 + t.b; }
        if(t.t&T.ROAD){ t.pollution += world.tiles[idx(x,y)].traffic*0.03; }
        // crime higher with poor land value and low police coverage
        let police=0; for(let dy=-6;dy<=6;dy++) for(let dx=-6;dx<=6;dx++){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; if(world.tiles[idx(nx,ny)].special===SPECIAL.POLICE) police++; }
        const unemployment = Math.max(0, world.demandI + world.demandC < 0 ? -(world.demandI+world.demandC) : 0);
        t.crime += clamp(5 - police*0.3 + unemployment*0.1, 0, 8);
        // random fires; fire stations suppress
        let fireCover=0; for(let dy=-5;dy<=5;dy++) for(let dx=-5;dx<=5;dx++){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; if(world.tiles[idx(nx,ny)].special===SPECIAL.FIRE) fireCover++; }
        if((t.zone!==ZONE.NONE || t.special!==SPECIAL.NONE) && Math.random()<0.0008*(1+Math.max(0,t.pollution-10)/30)) t.fire += 15 - fireCover;
        if(t.fire>70 && (t.zone!==ZONE.NONE || t.special!==SPECIAL.NONE)){
          // burn down
          t.zone = ZONE.NONE; t.special=SPECIAL.NONE; t.b=0; t.t = t.t & T.ROAD; t.u = t.u & (U.POWER|U.PIPE); t.pollution += 20; ui.log('A fire destroyed a building.');
        }
      }
    }

    // Ecology helpers and simulation
    function windAt(x,y){ const wx = 0.9 + 0.2*Math.sin(y*0.08 + time.t*0.2); const wy = 0.1 + 0.2*Math.sin(x*0.06 - time.t*0.15); const wl=Math.hypot(wx,wy)||1; return [wx/wl, wy/wl]; }
    function computeTempAndMoisture(){
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t=world.tiles[idx(x,y)]; const ny=y/SIZE; const coastal = t.ocean?0.0: Math.min(1, Math.abs(distanceToOcean(x,y)/8));
        const base = 28 - 16*ny; const diurnal = (Math.cos(world.dayPhase*2*Math.PI)*6) * (0.4 + 0.6*(1-coastal));
        t.temp = base + diurnal;
        const dWater = Math.min(distanceToWater(x,y)/12, 1);
        t.moisture = clamp(0.15 + (1-dWater)*0.7, 0, 1);
      }
      function distanceToWater(x,y){ let d=9999; for(let dy=-6;dy<=6;dy++) for(let dx=-6;dx<=6;dx++){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; if(world.tiles[idx(nx,ny)].water){ d=Math.min(d, Math.hypot(dx,dy)); } } return d===9999? 9999 : d; }
      function distanceToOcean(x,y){ let d=9999; for(let dy=-6;dy<=6;dy++) for(let dx=-6;dx<=6;dx++){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; if(world.tiles[idx(nx,ny)].ocean){ d=Math.min(d, Math.hypot(dx,dy)); } } return d===9999? 9999 : d; }
    }
    function simulateEcologyMonthly(){
      let food=0, wood=0; // simple yields
      // global atmospheric adjustments
      let deltaO2=0, deltaCO2=0;
      for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
        const t=world.tiles[idx(x,y)];
        if(t.water) continue;
        // trees grow/shrink
        const tempFactor = clamp(1 - Math.abs(t.temp-20)/18, 0, 1);
        const moist = t.moisture;
        const poll = clamp(t.pollution/100, 0, 1);
        let growth = (moist*0.6 + tempFactor*0.4) * (1 - poll*0.7);
        if(t.zone===ZONE.IND) growth *= 0.5;
        t.trees = clamp((t.trees||0) + (growth*3 - 1.5), 0, 100);
        // parks promote trees
        if(t.zone===ZONE.PARK) t.trees = clamp(t.trees + 1.5, 0, 100);
        // forestry harvest
        if(t.special===SPECIAL.FORESTRY){ let cut = Math.min(t.trees, 4); t.trees -= cut; wood += cut*2; }
        // farms produce food; consume moisture
        if(t.zone===ZONE.FARM){ const yieldF = clamp(moist*tempFactor*6, 0, 6); food += yieldF; t.moisture = clamp(t.moisture - 0.1, 0, 1); }
        if(t.special===SPECIAL.RANCH){ const yieldR = clamp(tempFactor*3 + moist*2, 0, 5); food += yieldR; }
        // atmosphere exchange from trees and industry
        deltaO2 += t.trees*0.002 - (t.zone===ZONE.IND? 0.02: 0);
        deltaCO2 += (t.zone===ZONE.IND? 0.03: 0) - t.trees*0.0015;
      }
      world.eco.o2 = clamp(world.eco.o2 + deltaO2/ (SIZE*SIZE/100), 15, 25);
      world.eco.co2 = clamp(world.eco.co2 + deltaCO2/ (SIZE*SIZE/100), 0.03, 0.2);
      // convert a portion of resources into export income
      const income = Math.round(food*2 + wood*1.5);
      world.eco.food = (world.eco.food||0) + food;
      world.eco.wood = (world.eco.wood||0) + wood;
      return income;
    }

    function budgetTick(){
      const pop = world.popR + world.popC + world.popI;
      const income = Math.round(pop * (world.taxRate/100) * 8);
      // service costs
      let roads=0, svc=0, util=0;
      for(let i=0;i<world.tiles.length;i++){
        const t=world.tiles[i];
        if(t.t&T.ROAD) roads += 1;
        if(t.u&(U.POWER|U.PIPE)) util += 0.5;
        if(t.special===SPECIAL.FIRE||t.special===SPECIAL.POLICE||t.special===SPECIAL.SCHOOL) svc += 40;
        if(t.special===SPECIAL.POWER_PLANT) svc += 150; if(t.special===SPECIAL.WATER_PUMP) svc += 60;
      }
      // ecology monthly updates and resource income
      const ecoIncome = simulateEcologyMonthly();
      const expenses = Math.round(roads*0.2 + util + svc);
      const delta = income + ecoIncome - expenses;
      if(!world.infiniteMoney) world.money += delta;
      const monthly = document.getElementById('monthly');
      monthly.textContent = (delta>=0? '+$':'-$') + Math.abs(delta);
      monthly.className = 'pill ' + (delta>=0? '' : 'neg');
    }

    function recompute(){
      computePower();
      computeWater();
      computeOcean();
      // update temperature and moisture baseline each recompute (cheap approximations)
      computeTempAndMoisture();
      simulateTraffic();
      simulateExternalities();
      computeLandValue();
      developZones();
    }

    // Building
    function costOf(tool){ return Tools.find(t=>t.id===tool)?.cost ?? 0; }
    function trySpend(cost){
      if(world.infiniteMoney) return true;
      if(world.money >= cost){ world.money -= cost; return true; }
      ui.log('Insufficient funds.');
      return false;
    }
    function applyBrush(x,y,fn){ const b = ui.brush; for(let dy=0; dy<b; dy++) for(let dx=0; dx<b; dx++){ const nx=x+dx, ny=y+dy; if(inb(nx,ny)) fn(nx,ny); } }

    function bulldoze(x,y){ const t=world.tiles[idx(x,y)]; if(t.water) return; t.zone=ZONE.NONE; t.special=SPECIAL.NONE; t.b=0; t.t=T.NONE; t.u=U.NONE; }
    function place(x,y){
      const t=world.tiles[idx(x,y)];
      switch(ui.tool){
        case 'bulldoze': bulldoze(x,y); return true;
        case 'raise': t.h = clamp(t.h+1,0,12); t.water = t.h<=SEA; return true;
        case 'lower': t.h = clamp(t.h-1,0,12); t.water = t.h<=SEA; return true;
        case 'smooth': {
          let s=t.h,c=1; for4(x,y,(nx,ny)=>{ if(!inb(nx,ny)) return; s+=world.tiles[idx(nx,ny)].h; c++; }); t.h = Math.round(s/c); t.water=t.h<=SEA; return true; }
        case 'road': if(!t.water){ t.t = t.t|T.ROAD; return true; } return false;
        case 'rail': if(!t.water){ t.t = t.t|T.RAIL; return true; } return false;
        case 'powerline': if(!t.water){ t.u = t.u|U.POWER; return true; } return false;
        case 'pipe': if(!t.water){ t.u = t.u|U.PIPE; return true; } return false;
        case 'park': if(!t.water){ t.zone = ZONE.PARK; t.special=SPECIAL.NONE; t.b=0; return true; } return false;
        case 'farm': if(!t.water){ t.zone = ZONE.FARM; t.special=SPECIAL.NONE; t.b=0; return true; } return false;
        case 'res': if(!t.water){ t.zone = ZONE.RES; t.special=SPECIAL.NONE; t.b=0; return true; } return false;
        case 'com': if(!t.water){ t.zone = ZONE.COM; t.special=SPECIAL.NONE; t.b=0; return true; } return false;
        case 'ind': if(!t.water){ t.zone = ZONE.IND; t.special=SPECIAL.NONE; t.b=0; return true; } return false;
        case 'powerplant': if(!t.water){ t.special=SPECIAL.POWER_PLANT; t.zone=ZONE.SPECIAL; t.b=0; return true; } return false;
        case 'waterpump': if(!t.water){ t.special=SPECIAL.WATER_PUMP; t.zone=ZONE.SPECIAL; t.b=0; return true; } return false;
        case 'fire': if(!t.water){ t.special=SPECIAL.FIRE; t.zone=ZONE.SPECIAL; t.b=0; return true; } return false;
        case 'police': if(!t.water){ t.special=SPECIAL.POLICE; t.zone=ZONE.SPECIAL; t.b=0; return true; } return false;
        case 'school': if(!t.water){ t.special=SPECIAL.SCHOOL; t.zone=ZONE.SPECIAL; t.b=0; return true; } return false;
        case 'ranch': if(!t.water){ t.special=SPECIAL.RANCH; t.zone=ZONE.SPECIAL; t.b=0; return true; } return false;
        case 'forestry': if(!t.water){ t.special=SPECIAL.FORESTRY; t.zone=ZONE.SPECIAL; t.b=0; return true; } return false;
      }
      return false;
    }

    function updateCostPreview(){
      const span = document.getElementById('costPreview');
      span.textContent = `$${costOf(ui.tool) * ui.brush*ui.brush}`;
    }

    // Input
    let hoverTile = null; let painting=false; let currentDrag=null; let lastPaintTime=0;
    canvas.addEventListener('mousemove', (e)=>{
      if(cam.dragging){ const dx=e.clientX-cam.lx, dy=e.clientY-cam.ly; cam.x -= dx/cam.scale; cam.y -= dy/cam.scale; cam.lx=e.clientX; cam.ly=e.clientY; return; }
      const [tx,ty] = screenToTile(e.offsetX,e.offsetY); hoverTile = [tx,ty]; if(painting){
        const now = performance.now(); if(now - lastPaintTime > 12){ dragPaint(tx,ty); lastPaintTime = now; }
      }
    });
    canvas.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });
    canvas.addEventListener('mousedown', (e)=>{
      if(e.button===1){ /* middle */ cam.dragging=true; cam.lx=e.clientX; cam.ly=e.clientY; return; }
      if(e.button===2){ /* right */ cam.dragging=true; cam.lx=e.clientX; cam.ly=e.clientY; return; }
      const [tx,ty] = screenToTile(e.offsetX,e.offsetY); if(!inb(tx,ty)) return;
      if(ui.query){ queryAt(tx,ty); return; }
      painting=true; currentDrag=[[tx,ty],[tx,ty]]; dragPaint(tx,ty,true);
    });
    window.addEventListener('mouseup', ()=>{ cam.dragging=false; if(painting){ finalizeDrag(); } painting=false; currentDrag=null; });
    canvas.addEventListener('wheel', (e)=>{ const prev=cam.scale; cam.scale=clamp(cam.scale*(e.deltaY<0?1.1:0.9), 0.5, 4.0); const [mx,my]=[e.offsetX,e.offsetY]; const [tx,ty]=screenToTile(mx,my); const [sx,sy]=worldToScreen(tx+0.5,ty+0.5); cam.x += (mx-sx)/cam.scale; cam.y += (my-sy)/cam.scale; e.preventDefault(); });
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      // tool hotkeys
      const found = Tools.find(t=>t.key.toLowerCase()===k);
      if(found){ ui.setTool(found.id); updateCostPreview(); return; }
      if(k==='r'){ cam.x=SIZE*TILE/2; cam.y=SIZE*TILE/2; cam.scale=2.0; }
      if(k==='arrowup'||k==='w'){ cam.y -= 16; }
      if(k==='arrowdown'||k==='s'){ cam.y += 16; }
      if(k==='arrowleft'||k==='a'){ cam.x -= 16; }
      if(k==='arrowright'||k==='d'){ cam.x += 16; }
      if(k==='q'){ ui.setTool('query'); }
      if(k===' '){ togglePause(); }
    });

    function dragPaint(tx,ty,first=false){ if(!currentDrag) currentDrag=[[tx,ty],[tx,ty]]; currentDrag[1]=[tx,ty]; if(first) currentDrag[0]=[tx,ty]; }
    function finalizeDrag(){
      if(!currentDrag) return;
      const [a1,b1]=currentDrag[0], [a2,b2]=currentDrag[1];
      const x1=Math.min(a1,a2), y1=Math.min(b1,b2), x2=Math.max(a1,a2), y2=Math.max(b1,b2);
      const b=ui.brush;
      const isLinearTool = (['road','rail','powerline','pipe'].includes(ui.tool) && b===1);
      // If linear tool with brush 1, draw a line path using Bresenham
      if(isLinearTool){
        const line = [];
        let x=a1, y=b1; const dx=Math.abs(a2-a1), dy=Math.abs(b2-b1); const sx=a1<a2?1:-1; const sy=b1<b2?1:-1; let err = dx-dy;
        while(true){ if(inb(x,y)) line.push([x,y]); if(x===a2 && y===b2) break; const e2=2*err; if(e2>-dy){ err-=dy; x+=sx; } if(e2<dx){ err+=dx; y+=sy; } }
        const unique = Array.from(new Set(line.map(([x,y])=> idx(x,y)))).map(i=> [i%SIZE, Math.floor(i/SIZE)]);
        const total = unique.length * costOf(ui.tool);
        if(total>0 && !trySpend(total)){ ui.log('Build canceled.'); return; }
        let any=false; unique.forEach(([x,y])=>{ if(place(x,y)) any=true; });
        if(any) sfx.build();
        recompute(); return;
      }
      // Default rectangular placement
      const total = (x2-x1+1)*(y2-y1+1)*b*b*costOf(ui.tool);
      if(total>0 && !trySpend(total)) { ui.log('Build canceled.'); return; }
      let any=false; for(let y=y1; y<=y2; y+=b){ for(let x=x1; x<=x2; x+=b){ applyBrush(x,y, (nx,ny)=>{ const ok=place(nx,ny); if(ok) any=true; }); } }
      if(any){ sfx.build(); }
      recompute();
    }

    function queryAt(x,y){ const t=world.tiles[idx(x,y)]; const parts=[]; parts.push(`Tile ${x},${y}`); parts.push(`Elev ${t.h}${t.water?' (water)':''}`); if(t.zone===ZONE.RES) parts.push(`Residential L${t.b+1}`); if(t.zone===ZONE.COM) parts.push(`Commercial L${t.b+1}`); if(t.zone===ZONE.IND) parts.push(`Industrial L${t.b+1}`); if(t.zone===ZONE.PARK) parts.push('Park'); if(t.special!==SPECIAL.NONE){ parts.push(['','Power Plant','Water Pump','Fire','Police','School'][t.special]); }
      parts.push(`Road:${(t.t&T.ROAD)?'Y':'N'} Rail:${(t.t&T.RAIL)?'Y':'N'} Pwr:${(t.u&U.POWER)?'Y':'N'} Pipe:${(t.u&U.PIPE)?'Y':'N'}`);
      parts.push(`Powered:${t.powered?'Y':'N'} Watered:${t.watered?'Y':'N'}`);
      parts.push(`Pollution:${t.pollution.toFixed(0)} Crime:${t.crime.toFixed(0)} Traffic:${t.traffic.toFixed(0)} Land:${t.land}`);
      ui.log(parts.join(' | '));
    }

    function togglePause(){ const btns = document.querySelectorAll('#topbar .speed button'); if(world.speed>0){ world.speed=0; } else { world.speed=1.0; } btns.forEach(b=> b.classList.toggle('active', parseFloat(b.dataset.speed||'0')===world.speed)); }

    // Save / Load
    function serialize(){ return JSON.stringify({ world, tiles: world.tiles }); }
    function deserialize(s){ try{ const o=JSON.parse(s); Object.assign(world, o.world); const arr = o.tiles; for(let i=0;i<world.tiles.length;i++){ Object.assign(world.tiles[i], arr[i]); } ui.log('Loaded city.'); recompute(); }catch(e){ ui.log('Load failed.'); } }

    // UI wiring
    document.getElementById('brush').addEventListener('change', (e)=>{ ui.brush=parseInt(e.target.value); updateCostPreview(); });
    document.getElementById('overlay').addEventListener('change', (e)=>{ ui.setOverlay(e.target.value); renderOverlayLegend(); });
    document.getElementById('queryBtn').addEventListener('click', ()=> ui.setTool('query'));
    document.getElementById('helpBtn').addEventListener('click', ()=> ui.showHelp());
    document.getElementById('helpClose').addEventListener('click', ()=> ui.hideHelp());
    document.getElementById('help').addEventListener('click', (e)=>{ if(e.target && e.target.id==='help') ui.hideHelp(); });
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ ui.hideHelp(); }});
    document.getElementById('newMap').addEventListener('click', ()=>{ if(confirm('Start new random map? Unsaved progress will be lost.')){ seedMap(); world.money=START_MONEY; world.month=0; ui.log('New city founded.'); recompute(); } });
    document.getElementById('nccMap').addEventListener('click', ()=>{ if(confirm('Start New Castle County map? Unsaved progress will be lost.')){ seedNewCastle(); world.money=START_MONEY; world.month=0; ui.log('Welcome to New Castle County, DE.'); recompute(); } });
    document.getElementById('saveBtn').addEventListener('click', ()=>{ localStorage.setItem('micropolis_save', serialize()); ui.log('Saved to localStorage.'); });
    document.getElementById('loadBtn').addEventListener('click', ()=>{ const s=localStorage.getItem('micropolis_save'); if(s) deserialize(s); else ui.log('No save found.'); });
    document.getElementById('taxRate').addEventListener('change', (e)=>{ world.taxRate=parseFloat(e.target.value)||7; ui.log(`Tax rate set to ${world.taxRate}%`); });
    document.querySelectorAll('#topbar .speed button').forEach(btn=> btn.addEventListener('click', ()=>{ document.querySelectorAll('#topbar .speed button').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); world.speed=parseFloat(btn.dataset.speed||'1'); }));
    document.getElementById('infiniteMoney').addEventListener('change', (e)=>{ world.infiniteMoney = e.target.checked; });

    function renderOverlayLegend(){
      const el = document.getElementById('overlayLegend');
      const v = ui.overlay; el.innerHTML='';
      const add = (k,desc)=>{ const d=document.createElement('div'); d.textContent=`${k}: ${desc}`; el.appendChild(d); };
      if(v==='power') add('Yellow','Powered');
      if(v==='water') add('Blue','Watered');
      if(v==='traffic') add('Orange','Heavier traffic');
      if(v==='pollution') add('Gray','Dirtier');
      if(v==='crime') add('Pink','More crime');
      if(v==='land') add('Redâ†’Green','Lowâ†’High value');
      if(v==='zones') add('Colors','Zone types');
      if(v==='fire') add('Red','Fires');
      if(v==='moisture') add('Blue','Higher soil moisture');
      if(v==='temp') add('Blueâ†’Red','Coolerâ†’Warmer');
      if(v==='forest') add('Green','More trees');
      if(v==='o2') add('Cyan','Higher O2');
      if(v==='co2') add('Purple','Higher CO2');
    }

    // HUD update loop
    function hud(){
      document.getElementById('money').textContent = world.infiniteMoney ? 'âˆž' : `$${world.money.toLocaleString()}`;
      document.getElementById('datePill').textContent = gameDate();
      const pop = world.popR + world.popC + world.popI; document.getElementById('popPill').textContent = `Pop ${pop.toLocaleString()}`;
      document.getElementById('verPill').textContent = VERSION;
      setTimeout(hud, 200);
    }

    // Time and sim loop
    let acc = 0; let last = performance.now();
    function tick(){
      const now = performance.now(); const dt = (now-last)/1000; last = now;
      acc += dt * (world.speed||0);
      const anim = Math.max(0, world.speed/10);
      time.t += dt * anim;
      world.dayPhase = (world.dayPhase + dt * anim / DAY_SECONDS) % 1;
      // simulation sub-steps
      if(acc > 0.5){ recompute(); acc = 0.0; }
      // monthly budget
      if(world.speed>0){
        const monthStep = dt * world.speed / MONTH_SECONDS;
        world._mAcc = (world._mAcc||0) + monthStep;
        if(world._mAcc >= 1){
          world.month += 1;
          world._mAcc -= 1;
          budgetTick();
          // Fireworks every New Year (January)
          if(world.month % 12 === 0){ spawnFireworks(); ui.log('Happy New Year! ðŸŽ†'); }
        }
      }
      // occasionally spawn birds and boats
      if(Math.random()<0.01){ spawnBird(); }
      if(Math.random()<0.006){ spawnBoat(); }
      requestAnimationFrame(tick);
    }

    // Catchier WebAudio music + SFX (light sequencer)
    const audio = { ctx:null, master:null, musicGain:null, on:false, timer:null };
    function audioInit(){ if(audio.ctx) return; const ctx = new (window.AudioContext||window.webkitAudioContext)(); audio.ctx=ctx; const master=ctx.createGain(); master.gain.value=0.5; master.connect(ctx.destination); audio.master=master; audio.musicGain=ctx.createGain(); audio.musicGain.gain.value=0.25; audio.musicGain.connect(master); startMusic(); }
    function note(freq, dur, tOffset, type='sine', gain=0.12){ if(!audio.on) return; const t0 = audio.ctx.currentTime + tOffset; const o=audio.ctx.createOscillator(); const g=audio.ctx.createGain(); o.type=type; o.frequency.setValueAtTime(freq, t0); o.connect(g); g.connect(audio.musicGain); g.gain.setValueAtTime(0,t0); g.gain.linearRampToValueAtTime(gain,t0+0.02); g.gain.exponentialRampToValueAtTime(0.001,t0+dur); o.start(t0); o.stop(t0+dur+0.05); }
    function hat(tOffset){ if(!audio.on) return; const ctx=audio.ctx; const t0=ctx.currentTime+tOffset; const buf=ctx.createBuffer(1, 2205, ctx.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * Math.exp(-i/400); } const src=ctx.createBufferSource(); src.buffer=buf; const g=ctx.createGain(); g.gain.value=0.08; src.connect(g); g.connect(audio.master); src.start(t0); }
    function kick(tOffset){ if(!audio.on) return; const t0=audio.ctx.currentTime+tOffset; const o=audio.ctx.createOscillator(); const g=audio.ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(120, t0); o.frequency.exponentialRampToValueAtTime(40, t0+0.15); g.gain.setValueAtTime(0.2, t0); g.gain.exponentialRampToValueAtTime(0.001, t0+0.18); o.connect(g); g.connect(audio.master); o.start(t0); o.stop(t0+0.2); }
    function startMusic(){ if(audio.timer) clearInterval(audio.timer); const bpm=78; const beat=60/bpm; let step=0; audio.timer = setInterval(()=>{
      if(!audio.on) return; const scale=[220,247,262,294,330,349,392,440]; const chordProg=[[0,3,5],[5,0,2],[4,6,1],[5,0,3]]; const ch = chordProg[Math.floor(step/8)%chordProg.length];
      // Bass + arpeggio
      const base = scale[ch[0]]/2; note(base, beat*0.45, 0, 'sine', 0.15);
      const arp = [scale[ch[0]], scale[ch[1]], scale[ch[2]], scale[ch[1]]];
      for(let i=0;i<4;i++){ note(arp[i], beat*0.4, i*(beat/2), 'triangle', 0.10); }
      // Percussion
      kick(0); hat(beat/2); hat(beat);
      step=(step+1)%16;
    }, (60/78)*1000);
    }
    const sfx = { build: ()=>{ if(!audio.ctx) return; const t=audio.ctx.currentTime; const o=audio.ctx.createOscillator(); const g=audio.ctx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(880, t); o.frequency.exponentialRampToValueAtTime(660, t+0.06); g.gain.setValueAtTime(0.0, t); g.gain.linearRampToValueAtTime(0.12, t+0.01); g.gain.exponentialRampToValueAtTime(0.001, t+0.2); o.connect(g); g.connect(audio.master); o.start(t); o.stop(t+0.22);} };
    document.getElementById('musicBtn').addEventListener('click', ()=>{ if(!audio.ctx) audioInit(); audio.on=!audio.on; document.getElementById('musicBtn').textContent = 'Music: ' + (audio.on? 'On':'Off'); if(audio.on && audio.ctx.state==='suspended') audio.ctx.resume(); });

    // bootstrap
    function init(){
      resize(); renderTools(); renderOverlayLegend();
      seedNewCastle(); recompute(); hud(); render(); tick();
      ui.log('Welcome! Build roads, a power plant, and zone R/C/I.');
    }
    init();
  })();
  </script>
  </body>
  </html>
